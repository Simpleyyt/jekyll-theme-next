---
title: LOB 2번 Write-up
date: 2017-8-26 18:05:00
categories: LOB
tags: LOB, cobolt
---

## LOB 2번

이번 레벨은 cobolt이다. 뭔가 1번이랑 비슷해 보인다.

    [gremlin@localhost gremlin]$ ls -l
    total 20
    -rwsr-sr-x    1 cobolt   cobolt      11970 Feb 26  2010 cobolt
    -rw-r--r--    1 gremlin  gremlin       291 Mar 29  2010 cobolt.c
    [gremlin@localhost gremlin]$ cat cobolt.c
    /*
            The Lord of the BOF : The Fellowship of the BOF
            - cobolt
            - small buffer
    */
    
    int main(int argc, char *argv[])
    {
        char buffer[16];
        if(argc < 2){
            printf("argv error\n");
            exit(0);
        }
        strcpy(buffer, argv[1]);
        printf("%s\n", buffer);
    }

`buffer`에 16바이트까지 인자를 전달받아 저장하고, `printf`로 출력한다. 이번에도 16 + 4, 즉 20바이트의 인자를 전달하면 오버플로우가 생긴다. 참고로 LOB가 돌아가는 리눅스 환경은 레드햇 6.2로 더미 메모리나 랜덤스택이 없다고 하니 더미 메모리같은것은 걱정하지 않아도 된다. 

    [gremlin@localhost gremlin]$ ./cobolt `python -c 'print "A"*19'`
    AAAAAAAAAAAAAAAAAAA
    [gremlin@localhost gremlin]$ ./cobolt `python -c 'print "A"*20'`
    AAAAAAAAAAAAAAAAAAAA
    Segmentation fault

알고보니 1번을 풀었듯이 환경변수로 풀면 되는 문제였다. 차이점이 버퍼 크기가 256byte -> 16byte로 줄어들었다는 것이다. 1번은 환경변수로 풀 필요가 없이 버퍼 자체에다가 쉘코드를 넣어도 되지만, 2번은 버퍼가 16byte밖에 되지 않는 관계로 환경변수를 사용할 수 밖에 없는 것이다.